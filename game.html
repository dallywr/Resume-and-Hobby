<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mini Wordle (Single-File)</title>
  <link rel="stylesheet" href="Styles/game.css">
  <link rel="stylesheet" href="Styles/nav.css">
</head>
<body>
  <div class="app" role="application" aria-label="Mini Wordle">
    <header>
      <h1>Mini Wordle</h1>
      <div class="meta">
        <div class="pill" id="attemptPill">Attempt: 1/6</div>
        <button class="btn" id="newGameBtn" type="button" title="Start a new game">New game</button>
      </div>
          <div class="common nav"></div>
    <div class="logodropdown">
        <img src="Images/nav.png" alt="Nav Menue" class="logo">
        <div class="dropdown-content">
        <a href="resume.html">Home</a>
        <a href="hobby.html">Hobby</a>
        <a href="game.html">Mini Wordle</a>
        </div>
    </div>
    </header>

    <div class="status" id="status">Type a 5-letter word and press <strong>Enter</strong>.</div>

    <div class="board" id="board" aria-label="Word grid"></div>

    <div class="keyboard" aria-label="On-screen keyboard">
      <div class="kb-row" id="kb1"></div>
      <div class="kb-row" id="kb2"></div>
      <div class="kb-row" id="kb3"></div>
    </div>

    <div class="footer">
      <div class="hint">
        Keys: <kbd>Enter</kbd> submit, <kbd>Backspace</kbd> delete
      </div>
      <div id="reveal" aria-live="polite"></div>
    </div>
  </div>

  <script>
    // Single-file Mini Wordle
    // - 5-letter words
    // - 6 attempts
    // - Random answer each game
    // - Basic validation via a small built-in dictionary

    const WORDS = [
      "ABOUT","ABOVE","ACTOR","ACUTE","ADMIT","ADOPT","AFTER","AGAIN","AGENT","AGREE",
      "ALERT","ALIEN","ALIVE","ALLOW","ALONE","ALONG","AMBER","ANGEL","APPLE","ARENA",
      "ARGUE","ARISE","ARMOR","AUDIO","AWAKE","AWARD","BACON","BASIC","BATCH","BEACH",
      "BEGAN","BEGIN","BEING","BLEND","BLOOM","BOOST","BRAVE","BREAD","BRICK","BRING",
      "BROAD","BROWN","BUILD","BUILT","CABLE","CALM","CANAL","CANDY","CARRY","CATCH",
      "CAUSE","CHAIN","CHAIR","CHART","CHASE","CHEAP","CHECK","CHESS","CHIEF","CHILD",
      "CHIME","CHOIR","CIVIL","CLAIM","CLASS","CLEAN","CLEAR","CLIMB","CLOCK","CLOSE",
      "COACH","COAST","COULD","COUNT","COURT","CRANE","CRASH","CRISP","CROWD","CROWN",
      "DAILY","DANCE","DATED","DEALT","DEBUT","DELAY","DEPTH","DOUBT","DOZEN","DRAFT",
      "DRIVE","EARLY","EARTH","EIGHT","ELITE","ENJOY","ENTER","EQUAL","ERROR","EVENT",
      "FAITH","FALSE","FANCY","FEAST","FIFTH","FIGHT","FINAL","FIREY","FIRST","FIXED",
      "FOCUS","FORCE","FORGE","FOUND","FRAME","FRESH","FRONT","FRUIT","GIANT","GLASS",
      "GLOBE","GRACE","GRADE","GRAIN","GRAND","GRANT","GRASS","GREAT","GREEN","GREET",
      "GROUP","GUARD","HAPPY","HEART","HEAVY","HONEY","HORSE","HOTEL","HOUSE","HUMAN",
      "IDEAL","IMAGE","INDEX","INNER","ISSUE","JEWEL","JOINT","JUDGE","JUICE","KNOWN",
      "LABEL","LARGE","LASER","LATER","LAUGH","LAYER","LEARN","LEAST","LEMON","LIGHT",
      "LIMIT","LOCAL","LOGIC","LOOSE","LUCKY","LUNCH","MAGIC","MAJOR","MAKER","MARCH",
      "MATCH","MAYBE","MEDAL","MERIT","METAL","METER","MIGHT","MINOR","MIXED","MODEL",
      "MONEY","MONTH","MOTOR","MOUNT","MOUSE","MUSIC","NEVER","NIGHT","NINJA","NOBLE",
      "NOISE","NORTH","NOVEL","NURSE","OCEAN","OFFER","OFTEN","OPERA","ORDER","OTHER",
      "PANEL","PARTY","PAUSE","PEACE","PHASE","PHONE","PHOTO","PIECE","PILOT","PITCH",
      "PLACE","PLAIN","PLANT","PLATE","POINT","POWER","PRESS","PRICE","PRIDE","PRIME",
      "PRINT","PROOF","PROUD","QUEEN","QUICK","QUIET","RADIO","RAISE","RANGE","RAPID",
      "RATIO","REACH","REACT","READY","REALM","REBEL","REFER","REIGN","RELAX","REPLY",
      "RIGHT","RIVER","ROBOT","ROUGH","ROUND","ROUTE","ROYAL","RUGBY","SAFER","SAINT",
      "SCALE","SCENE","SCOPE","SCORE","SCOUT","SENSE","SERVE","SHARE","SHARP","SHELF",
      "SHIFT","SHINE","SHIRT","SHOCK","SHOOT","SHORT","SHOWN","SIGHT","SINCE","SKILL",
      "SLEEP","SMILE","SOLID","SOUND","SOUTH","SPACE","SPARE","SPEAK","SPEED","SPENT",
      "SPICE","SPLIT","SPORT","STAFF","STAGE","STAND","START","STATE","STEAM","STEEL",
      "STICK","STILL","STONE","STORE","STORM","STORY","STRAP","STUDY","STYLE","SUGAR",
      "SUITE","SUPER","SWEET","TABLE","TAKEN","TASTE","TEACH","THEME","THERE","THICK",
      "THINK","THIRD","THOSE","THROW","TIGER","TITLE","TODAY","TOPIC","TOTAL","TOUCH",
      "TOUGH","TOWER","TRACK","TRADE","TRAIL","TRAIN","TREAT","TRUCK","TRULY","TRUST",
      "UNDER","UNION","UNITY","UPPER","URBAN","USAGE","VALUE","VIDEO","VIRUS","VITAL",
      "VOICE","WATER","WHEEL","WHERE","WHITE","WHOLE","WOMAN","WORLD","WORTH","WOULD",
      "WRITE","WRONG","YOUNG"
    ];

    const VALID_WORDS = new Set(WORDS); // Small dictionary for validation

    const MAX_TRIES = 6;
    const WORD_LEN = 5;

    const boardEl = document.getElementById("board");
    const statusEl = document.getElementById("status");
    const revealEl = document.getElementById("reveal");
    const attemptPill = document.getElementById("attemptPill");
    const newGameBtn = document.getElementById("newGameBtn");

    const kb1 = document.getElementById("kb1");
    const kb2 = document.getElementById("kb2");
    const kb3 = document.getElementById("kb3");

    const KEY_ROWS = [
      ["Q","W","E","R","T","Y","U","I","O","P"],
      ["A","S","D","F","G","H","J","K","L"],
      ["ENTER","Z","X","C","V","B","N","M","⌫"]
    ];

    let answer = "";
    let row = 0;
    let col = 0;
    let grid = Array.from({length: MAX_TRIES}, () => Array(WORD_LEN).fill(""));
    let locked = false;

    // key state priority: correct > present > absent
    const keyState = new Map();

    function pickAnswer(){
      return WORDS[Math.floor(Math.random() * WORDS.length)];
    }

    function buildBoard(){
      boardEl.innerHTML = "";
      for(let r=0; r<MAX_TRIES; r++){
        const rowEl = document.createElement("div");
        rowEl.className = "row";
        rowEl.setAttribute("data-row", r);
        for(let c=0; c<WORD_LEN; c++){
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.setAttribute("data-col", c);
          tile.textContent = "";
          rowEl.appendChild(tile);
        }
        boardEl.appendChild(rowEl);
      }
    }

    function buildKeyboard(){
      [kb1,kb2,kb3].forEach(el => el.innerHTML = "");
      KEY_ROWS[0].forEach(k => kb1.appendChild(makeKey(k)));
      KEY_ROWS[1].forEach(k => kb2.appendChild(makeKey(k)));
      KEY_ROWS[2].forEach(k => kb3.appendChild(makeKey(k)));
    }

    function makeKey(label){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "key";
      btn.textContent = label;
      btn.setAttribute("data-key", label);

      if(label === "ENTER" || label === "⌫") btn.classList.add("wide");

      btn.addEventListener("click", () => {
        if(label === "ENTER") onEnter();
        else if(label === "⌫") onBackspace();
        else onLetter(label);
      });
      return btn;
    }

    function setStatus(html, type=null){
      statusEl.innerHTML = html;
      statusEl.classList.remove("err","win");
      if(type) statusEl.classList.add(type);
    }

    function updateAttemptPill(){
      attemptPill.textContent = `Attempt: ${Math.min(row+1, MAX_TRIES)}/${MAX_TRIES}`;
    }

    function getTile(r,c){
      const rowEl = boardEl.querySelector(`.row[data-row="${r}"]`);
      return rowEl ? rowEl.querySelector(`.tile[data-col="${c}"]`) : null;
    }

    function renderRow(r){
      for(let c=0; c<WORD_LEN; c++){
        const t = getTile(r,c);
        if(!t) continue;
        const v = grid[r][c];
        t.textContent = v;
        t.classList.toggle("filled", !!v);
      }
    }

    function popTile(r,c){
      const t = getTile(r,c);
      if(!t) return;
      t.classList.add("pop");
      setTimeout(()=>t.classList.remove("pop"), 80);
    }

    function normalizeWord(arr){
      return arr.join("");
    }

    function onLetter(ch){
      if(locked) return;
      if(row >= MAX_TRIES) return;
      if(col >= WORD_LEN) return;
      grid[row][col] = ch;
      renderRow(row);
      popTile(row,col);
      col++;
    }

    function onBackspace(){
      if(locked) return;
      if(row >= MAX_TRIES) return;
      if(col <= 0) return;
      col--;
      grid[row][col] = "";
      renderRow(row);
    }

    function onEnter(){
      if(locked) return;
      if(row >= MAX_TRIES) return;

      const guess = normalizeWord(grid[row]);
      if(guess.length !== WORD_LEN || grid[row].some(x => !x)){
        setStatus(`<span class="err">Not enough letters.</span>`, "err");
        return;
      }
      if(!VALID_WORDS.has(guess)){
        setStatus(`<span class="err">Not in word list.</span>`, "err");
        return;
      }

      const {states} = scoreGuess(guess, answer);
      applyRowColors(row, states);
      updateKeyboard(guess, states);

      if(guess === answer){
        locked = true;
        setStatus(`<span class="win">Correct.</span> You got it in <strong>${row+1}</strong> attempt(s).`, "win");
        revealEl.textContent = `Answer: ${answer}`;
        return;
      }

      row++;
      col = 0;
      updateAttemptPill();

      if(row >= MAX_TRIES){
        locked = true;
        setStatus(`<span class="err">Out of tries.</span> Better luck next time.`, "err");
        revealEl.textContent = `Answer: ${answer}`;
      } else {
        setStatus(`Keep going. Try #<strong>${row+1}</strong>.`);
      }
    }

    // Wordle-style scoring with duplicate handling
    function scoreGuess(guess, answer){
      const states = Array(WORD_LEN).fill("absent");
      const a = answer.split("");
      const g = guess.split("");

      // First pass: correct
      for(let i=0;i<WORD_LEN;i++){
        if(g[i] === a[i]){
          states[i] = "correct";
          a[i] = null; // consume
          g[i] = null; // mark used
        }
      }
      // Second pass: present
      for(let i=0;i<WORD_LEN;i++){
        if(g[i] == null) continue;
        const idx = a.indexOf(g[i]);
        if(idx !== -1){
          states[i] = "present";
          a[idx] = null; // consume
        }
      }
      return {states};
    }

    function applyRowColors(r, states){
      for(let c=0;c<WORD_LEN;c++){
        const t = getTile(r,c);
        if(!t) continue;
        t.classList.remove("absent","present","correct");
        t.classList.add(states[c]);
      }
    }

    function statePriority(s){
      if(s === "correct") return 3;
      if(s === "present") return 2;
      return 1;
    }

    function updateKeyboard(guess, states){
      for(let i=0;i<WORD_LEN;i++){
        const letter = guess[i];
        const newState = states[i];
        const oldState = keyState.get(letter);

        if(!oldState || statePriority(newState) > statePriority(oldState)){
          keyState.set(letter, newState);
          const keyBtn = document.querySelector(`.key[data-key="${letter}"]`);
          if(keyBtn){
            keyBtn.classList.remove("absent","present","correct");
            keyBtn.classList.add(newState);
          }
        }
      }
    }

    function resetKeyboard(){
      keyState.clear();
      document.querySelectorAll(".key").forEach(k=>{
        k.classList.remove("absent","present","correct");
      });
    }

    function newGame(){
      answer = pickAnswer();
      row = 0;
      col = 0;
      locked = false;
      grid = Array.from({length: MAX_TRIES}, () => Array(WORD_LEN).fill(""));
      revealEl.textContent = "";
      setStatus(`Type a 5-letter word and press <strong>Enter</strong>.`);
      updateAttemptPill();
      buildBoard();
      buildKeyboard();
      resetKeyboard();
      // Uncomment to debug:
      // console.log("Answer:", answer);
    }

    // Keyboard input
    window.addEventListener("keydown", (e) => {
      if(e.key === "Enter") { e.preventDefault(); onEnter(); return; }
      if(e.key === "Backspace") { e.preventDefault(); onBackspace(); return; }
      const k = e.key.toUpperCase();
      if(k.length === 1 && k >= "A" && k <= "Z"){
        onLetter(k);
      }
    });

    newGameBtn.addEventListener("click", newGame);

    newGame();
  </script>
</body>
</html>
